<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>æ•°ç‹¬æ´¾å¯¹ Pro</title>
    <style>
      :root {
        --bg-1: #ffe8d6;
        --bg-2: #dff7f2;
        --ink: #243447;
        --primary: #ff7b54;
        --secondary: #00a6a6;
        --danger: #b23a48;
        --cell: #ffffffcc;
        --fixed: #243447;
        --input: #176b87;
        --selected: #fff4a3;
        --peer: #fff7cf;
        --conflict: #ffcdd2;
        --ok: #d6f5de;
        --focus: #2563eb;
      }

      body.high-contrast {
        --bg-1: #f8fafc;
        --bg-2: #dbeafe;
        --ink: #0b132b;
        --cell: #ffffff;
        --fixed: #000000;
        --input: #0c4a6e;
        --selected: #fde047;
        --peer: #fef9c3;
        --conflict: #fca5a5;
        --ok: #86efac;
        --focus: #000000;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Trebuchet MS", "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
        color: var(--ink);
        min-height: 100vh;
        background: radial-gradient(circle at 10% 10%, var(--bg-2), transparent 45%),
          radial-gradient(circle at 90% 20%, #ffd6e0, transparent 40%),
          linear-gradient(120deg, #fef3c7, var(--bg-1));
        display: grid;
        place-items: center;
        padding: 16px;
      }

      body.large-font {
        font-size: 1.2em;
      }

      .app {
        width: min(1100px, 100%);
        display: grid;
        gap: 16px;
      }

      .panel {
        background: #ffffffd9;
        border-radius: 20px;
        backdrop-filter: blur(5px);
        box-shadow: 0 8px 20px #00000014;
        padding: 14px;
      }

      .top {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.2rem, 3vw, 1.8rem);
      }

      .badge {
        font-size: 0.9rem;
        background: #fff;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #00000012;
      }

      .meta-line {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .main {
        display: grid;
        gap: 14px;
        grid-template-columns: 1fr;
      }

      .board-wrap {
        display: grid;
        place-items: center;
      }

      .board {
        width: min(92vw, 560px);
        aspect-ratio: 1;
        display: grid;
        grid-template-columns: repeat(9, 1fr);
        grid-template-rows: repeat(9, 1fr);
        border: 3px solid var(--ink);
        border-radius: 8px;
        overflow: hidden;
        background: #fff;
        touch-action: manipulation;
      }

      .board.shake {
        animation: shake 0.25s linear;
      }

      @keyframes shake {
        0% { transform: translateX(0); }
        25% { transform: translateX(-6px); }
        50% { transform: translateX(6px); }
        75% { transform: translateX(-4px); }
        100% { transform: translateX(0); }
      }

      .cell {
        border: 1px solid #c7d4de;
        display: grid;
        place-items: center;
        font-size: clamp(1rem, 2.2vw, 1.6rem);
        font-weight: 700;
        background: var(--cell);
        user-select: none;
        cursor: pointer;
        text-align: center;
        white-space: pre-wrap;
        line-height: 1.1;
      }

      .cell.note {
        font-size: clamp(0.5rem, 1.2vw, 0.78rem);
        letter-spacing: 0.03em;
      }

      body.large-font .cell {
        font-size: clamp(1.15rem, 2.6vw, 1.8rem);
      }

      body.large-font .cell.note {
        font-size: clamp(0.66rem, 1.4vw, 0.92rem);
      }

      .cell:focus-visible,
      button:focus-visible,
      input:focus-visible,
      select:focus-visible {
        outline: 3px solid var(--focus);
        outline-offset: -2px;
      }

      .cell[data-col="2"],
      .cell[data-col="5"] {
        border-right: 3px solid var(--ink);
      }

      .cell[data-row="2"],
      .cell[data-row="5"] {
        border-bottom: 3px solid var(--ink);
      }

      .cell.fixed { color: var(--fixed); }
      .cell.input { color: var(--input); }
      .cell.selected { background: var(--selected); }
      .cell.peer { background: var(--peer); }
      .cell.conflict { background: var(--conflict); }
      .cell.good { background: var(--ok); }

      .controls {
        display: grid;
        gap: 10px;
      }

      .difficulty-row,
      .settings-row,
      .mode-row,
      .effect-row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 6px;
      }

      .lang-row {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
      }

      .settings-panel {
        display: grid;
        gap: 10px;
        padding: 10px;
        border: 1px dashed #00000026;
        border-radius: 12px;
        background: #ffffffa8;
      }

      .num-pad {
        display: grid;
        grid-template-columns: repeat(9, minmax(0, 1fr));
        gap: 6px;
      }

      button,
      select,
      input[type="range"] {
        border-radius: 10px;
        background: #fff;
        color: var(--ink);
        padding: 10px;
        font-weight: 700;
        border: 1px solid #0000001c;
      }

      button { cursor: pointer; }

      button:hover { transform: translateY(-1px); }
      button:active { transform: translateY(0); }

      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
      }

      .difficulty-row button.active,
      .mode-row button.active,
      .lang-row button.active,
      .effect-row button.active,
      .action-row button.active,
      .settings-row button.active {
        background: #172b4d;
        color: #fff;
      }

      .num-btn { min-height: 44px; }

      .btn-ico {
        display: inline-block;
        margin-right: 0.35em;
        width: 1em;
        text-align: center;
      }

      .action-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .primary {
        background: var(--primary);
        color: #fff;
      }

      .secondary {
        background: var(--secondary);
        color: #fff;
      }

      .warn {
        background: var(--danger);
        color: #fff;
      }

      .slider-wrap {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .slider-wrap input {
        width: 100%;
      }

      .info {
        font-size: 0.95rem;
        opacity: 0.9;
      }

      .toast {
        min-height: 1.2em;
        font-weight: 700;
      }

      .board-stats {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .leaderboard {
        background: #ffffffc7;
        border: 1px solid #00000014;
        border-radius: 12px;
        padding: 10px;
      }

      .leaderboard h2 {
        margin: 0 0 6px;
        font-size: 1rem;
      }

      .leaderboard ol {
        margin: 0;
        padding-left: 18px;
      }

      .leaderboard li { margin: 2px 0; }

      #fireworks {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 30;
      }

      #victoryBanner {
        position: fixed;
        top: 12vh;
        left: 50%;
        transform: translateX(-50%) scale(0.8);
        background: linear-gradient(120deg, #ff6b6b, #ffd166, #06d6a0);
        color: #13293d;
        border-radius: 999px;
        padding: 12px 24px;
        font-weight: 800;
        letter-spacing: 0.04em;
        box-shadow: 0 10px 28px #00000030;
        z-index: 35;
        opacity: 0;
        pointer-events: none;
      }

      #victoryBanner.show { animation: banner-pop 1.2s ease-out; }

      @keyframes banner-pop {
        0% { opacity: 0; transform: translateX(-50%) scale(0.65) translateY(30px); }
        20% { opacity: 1; transform: translateX(-50%) scale(1.08) translateY(0); }
        70% { opacity: 1; transform: translateX(-50%) scale(1); }
        100% { opacity: 0; transform: translateX(-50%) scale(0.95) translateY(-18px); }
      }

      body.victory-flash .panel { animation: victory-glow 0.9s ease-out 2; }

      @keyframes victory-glow {
        0% { box-shadow: 0 8px 20px #00000014; }
        50% { box-shadow: 0 0 0 6px #ffd16699, 0 0 0 12px #06d6a055, 0 8px 20px #00000014; }
        100% { box-shadow: 0 8px 20px #00000014; }
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: #00000066;
        z-index: 40;
        padding: 16px;
      }

      .modal.open { display: flex; }

      .modal-card {
        width: min(540px, 100%);
        background: #ffffff;
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 16px 36px #00000030;
      }

      .modal h3 {
        margin: 0 0 10px;
        font-size: 1.3rem;
      }

      .modal p { margin: 6px 0; }

      .modal-actions {
        margin-top: 12px;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .settings-modal .modal-card {
        width: min(700px, 100%);
        max-height: min(86vh, 760px);
        display: grid;
        grid-template-rows: auto 1fr;
        padding: 0;
        overflow: hidden;
      }

      .settings-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 14px 16px;
        border-bottom: 1px solid #00000012;
      }

      .settings-modal-header h3 {
        margin: 0;
      }

      .settings-modal-body {
        overflow: auto;
        padding: 12px 16px 16px;
      }

      .settings-modal .settings-panel {
        border: none;
        background: transparent;
        padding: 0;
      }

      @media (min-width: 980px) {
        .main {
          grid-template-columns: minmax(0, 580px) minmax(320px, 1fr);
          align-items: start;
        }

        .controls {
          position: sticky;
          top: 16px;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="fireworks"></canvas>
    <div id="victoryBanner">Perfect! æ•°ç‹¬é€šå…³</div>

    <div class="modal" id="resultModal" aria-modal="true" role="dialog">
      <div class="modal-card">
        <h3 id="resultTitle">ç»“æœ</h3>
        <div id="resultBody"></div>
        <div class="modal-actions">
          <button id="resultRetry" class="primary">å†æ¥ä¸€å±€</button>
          <button id="resultClose">å…³é—­</button>
        </div>
      </div>
    </div>

    <div class="modal settings-modal" id="settingsModal" aria-modal="true" role="dialog" aria-labelledby="settingsTitle">
      <div class="modal-card">
        <div class="settings-modal-header">
          <h3 id="settingsTitle">è®¾ç½®</h3>
          <button id="settingsClose">å…³é—­</button>
        </div>
        <div class="settings-modal-body">
          <div class="settings-panel" id="settingsPanel">
            <div class="mode-row" id="modeRow">
              <button id="modeNormal">æ™®é€š</button>
              <button id="modeDaily">æ¯æ—¥æŒ‘æˆ˜</button>
              <button id="copyDailyLink"><span class="btn-ico" aria-hidden="true">ğŸ”—</span>å¤åˆ¶ä»Šæ—¥é“¾æ¥</button>
            </div>

            <div class="lang-row" id="langRow">
              <button id="langZh">ä¸­æ–‡</button>
              <button id="langEn">English</button>
            </div>

            <div class="action-row">
              <button id="autoCandidates"><span class="btn-ico" aria-hidden="true">âš™</span>è‡ªåŠ¨å€™é€‰</button>
              <button id="clearCandidates"><span class="btn-ico" aria-hidden="true">âŠ˜</span>æ¸…ç©ºå€™é€‰</button>
            </div>

            <div class="settings-row" id="settingsRow">
              <button id="muteBtn" aria-pressed="false"><span class="btn-ico" aria-hidden="true">ğŸ”Š</span>é™éŸ³</button>
              <button id="contrastBtn" aria-pressed="false"><span class="btn-ico" aria-hidden="true">â—</span>é«˜å¯¹æ¯”</button>
              <button id="fontBtn" aria-pressed="false"><span class="btn-ico" aria-hidden="true">A+</span>å¤§å­—å·</button>
            </div>

            <div class="effect-row" id="effectRow">
              <button data-effect="low">ç‰¹æ•ˆä½</button>
              <button data-effect="medium">ç‰¹æ•ˆä¸­</button>
              <button data-effect="high">ç‰¹æ•ˆé«˜</button>
            </div>

            <div class="slider-wrap">
              <span id="volumeLabel">éŸ³é‡</span>
              <input type="range" id="volumeSlider" min="0" max="1" step="0.01" />
              <span id="volumeText">70%</span>
            </div>

            <div class="action-row">
              <button id="exportData"><span class="btn-ico" aria-hidden="true">â¬‡</span>å¯¼å‡ºæ•°æ®</button>
              <button id="importData"><span class="btn-ico" aria-hidden="true">â¬†</span>å¯¼å…¥æ•°æ®</button>
              <input type="file" id="importFile" accept="application/json" hidden />
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="app">
      <section class="panel top">
        <h1>æ•°ç‹¬æ´¾å¯¹ Pro</h1>
        <div class="meta-line">
          <div class="badge" id="meta">éš¾åº¦ï¼šä¸­ç­‰</div>
          <div class="badge" id="modeBadge">æ¨¡å¼ï¼šæ™®é€š</div>
          <div class="badge" id="dayBadge">æ—¥æœŸï¼š--</div>
          <div class="badge" id="timer">è®¡æ—¶ï¼š00:00</div>
          <div class="badge" id="score">å¾—åˆ†ï¼š120</div>
        </div>
      </section>

      <section class="panel main">
        <div class="board-wrap">
          <div class="board" id="board" aria-label="Sudoku board"></div>
        </div>

        <div class="controls">
          <div class="difficulty-row" id="difficultyRow"></div>
          <div class="num-pad" id="numPad"></div>

          <div class="action-row">
            <button id="noteMode"><span class="btn-ico" aria-hidden="true">âœ</span>ç¬”è®°æ¨¡å¼</button>
            <button id="undo"><span class="btn-ico" aria-hidden="true">â†¶</span>æ’¤é”€</button>
            <button id="redo"><span class="btn-ico" aria-hidden="true">â†·</span>é‡åš</button>
            <button id="erase"><span class="btn-ico" aria-hidden="true">âŒ«</span>æ“¦é™¤</button>
            <button id="hint"><span class="btn-ico" aria-hidden="true">ğŸ’¡</span>æç¤º</button>
            <button class="primary" id="newGame"><span class="btn-ico" aria-hidden="true">âŸ³</span>æ–°å¸ƒå±€</button>
            <button class="secondary" id="share"><span class="btn-ico" aria-hidden="true">ğŸ”—</span>åˆ†äº«è¿›åº¦</button>
            <button id="toggleSettings" aria-expanded="false"><span class="btn-ico" aria-hidden="true">âš™</span>è®¾ç½®</button>
          </div>

          <div class="board-stats">
            <div class="badge" id="filled">å·²å¡«ï¼š0/81</div>
            <div class="badge" id="best">æœ€ä½³ï¼š--:--</div>
            <div class="badge" id="danger">å¤±è´¥é˜ˆå€¼ï¼š30</div>
          </div>

          <div class="leaderboard">
            <h2 id="leaderboardTitle">æœ¬åœ°æ’è¡Œæ¦œï¼ˆå‰ 5ï¼‰</h2>
            <ol id="leaderboard"></ol>
          </div>

          <div class="info" id="status" aria-live="polite">ç‚¹å‡»ä¸€ä¸ªç©ºæ ¼å¼€å§‹ã€‚</div>
          <div class="toast" id="toast" role="status" aria-live="polite"></div>
        </div>
      </section>
    </div>

    <script>
      const Constants = {
        SIZE: 9,
        BOX: 3,
        DIGITS: [1, 2, 3, 4, 5, 6, 7, 8, 9],
        START_SCORE: 120,
        FAIL_THRESHOLD: 30,
        WRONG_PENALTY: 15,
        HINT_PENALTY: 8,
        URL_VERSION: "3",
        EXPORT_VERSION: "sudoku-party-export-v1",
        SCORE_KEY: "sudoku-party-scores-v3",
        DAILY_SCORE_KEY: "sudoku-party-daily-v1",
        SETTINGS_KEY: "sudoku-party-settings-v1",
      };

      const DIFFICULTIES = {
        easy: { holes: 38, target: 20 },
        medium: { holes: 46, target: 55 },
        hard: { holes: 54, target: 110 },
      };

      const I18N = {
        zh: {
          "app.title": "æ•°ç‹¬æ´¾å¯¹ Pro",
          "mode.normal": "æ™®é€š",
          "mode.daily": "æ¯æ—¥æŒ‘æˆ˜",
          "label.mode": "æ¨¡å¼ï¼š{mode}",
          "label.day": "æ—¥æœŸï¼š{day}",
          "label.timer": "è®¡æ—¶ï¼š{time}",
          "label.score": "å¾—åˆ†ï¼š{score}",
          "label.filled": "å·²å¡«ï¼š{filled}/81",
          "label.best.none": "æœ€ä½³ï¼š--:--",
          "label.best": "æœ€ä½³ï¼š{time} ï½œ {score}åˆ†",
          "label.failThreshold": "å¤±è´¥é˜ˆå€¼ï¼š{n}",
          "label.meta": "éš¾åº¦ï¼š{diff} ï½œ Seed: {seed}",
          "leaderboard.normal": "æœ¬åœ°æ’è¡Œæ¦œï¼ˆå‰ 5ï¼‰",
          "leaderboard.daily": "ä»Šæ—¥æ’è¡Œæ¦œï¼ˆ{day}ï¼Œå‰ 5ï¼‰",
          "leaderboard.empty.normal": "è¿˜æ²¡æœ‰æˆç»©ï¼Œå¿«å†²ä¸€æŠŠã€‚",
          "leaderboard.empty.daily": "ä»Šå¤©è¿˜æ²¡æœ‰æˆç»©ã€‚",
          "btn.note": "ç¬”è®°æ¨¡å¼",
          "btn.undo": "æ’¤é”€",
          "btn.redo": "é‡åš",
          "btn.erase": "æ“¦é™¤",
          "btn.hint": "æç¤º",
          "btn.newGame": "æ–°å¸ƒå±€",
          "btn.share": "åˆ†äº«è¿›åº¦",
          "btn.settings": "è®¾ç½®",
          "btn.copyDaily": "å¤åˆ¶ä»Šæ—¥é“¾æ¥",
          "btn.autoCandidates": "è‡ªåŠ¨å€™é€‰",
          "btn.clearCandidates": "æ¸…ç©ºå€™é€‰",
          "btn.mute": "é™éŸ³",
          "btn.contrast": "é«˜å¯¹æ¯”",
          "btn.font": "å¤§å­—å·",
          "btn.effect.low": "ç‰¹æ•ˆä½",
          "btn.effect.medium": "ç‰¹æ•ˆä¸­",
          "btn.effect.high": "ç‰¹æ•ˆé«˜",
          "btn.export": "å¯¼å‡ºæ•°æ®",
          "btn.import": "å¯¼å…¥æ•°æ®",
          "btn.retry": "å†æ¥ä¸€å±€",
          "btn.close": "å…³é—­",
          "settings.title": "è®¾ç½®",
          "label.volume": "éŸ³é‡",
          "diff.easy": "ç®€å•",
          "diff.medium": "ä¸­ç­‰",
          "diff.hard": "å›°éš¾",
          "status.failed": "åˆ†æ•°è·Œç ´é˜ˆå€¼ï¼Œæœ¬å±€å¤±è´¥ã€‚",
          "status.start": "ç‚¹å‡»ä¸€ä¸ªç©ºæ ¼å¼€å§‹ã€‚",
          "status.noteMode": "ç¬”è®°æ¨¡å¼å·²å¼€å¯ï¼Œç‚¹å‡»ç©ºæ ¼åè¾“å…¥æ•°å­—ã€‚",
          "status.fixed": "è¿™æ˜¯é¢„è®¾æ•°å­—ï¼Œä¸èƒ½ä¿®æ”¹ã€‚",
          "status.pos": "ç¬¬ {r} è¡Œï¼Œç¬¬ {c} åˆ—{mode}",
          "status.pos.noteSuffix": "ï¼ˆç¬”è®°æ¨¡å¼ï¼‰",
          "status.failWithAction": "åˆ†æ•°è·Œç ´é˜ˆå€¼ï¼Œæœ¬å±€å¤±è´¥ã€‚ç‚¹â€œå†æ¥ä¸€å±€â€ç»§ç»­ã€‚",
          "toast.fail": "æ¸¸æˆå¤±è´¥ï¼šæ‰£åˆ†è¿‡å¤šã€‚",
          "toast.autoCandidates.updated": "å·²è‡ªåŠ¨è¡¥å…¨å€™é€‰ï¼ˆ{n}æ ¼æ›´æ–°ï¼‰",
          "toast.autoCandidates.latest": "å€™é€‰å·²æ˜¯æœ€æ–°",
          "toast.clearCandidates": "å·²æ¸…ç©ºæ‰€æœ‰å€™é€‰ã€‚",
          "toast.restore": "å·²æ¢å¤ä½ åˆ†äº«çš„è¿›åº¦ã€‚",
          "toast.newPuzzle": "å¸ƒå±€å·²ç”Ÿæˆï¼Œç¥ä½ ç©å¾—å¼€å¿ƒï¼",
          "toast.noteUpdated": "å€™é€‰æ•°å·²æ›´æ–°ã€‚",
          "toast.wrong": "å¡«å†™é”™è¯¯ï¼Œå·²æ‰£åˆ†",
          "toast.correct": "å¡«å†™æ­£ç¡®ã€‚",
          "toast.erased": "å·²æ“¦é™¤è¯¥æ ¼ã€‚",
          "toast.noHint": "æ²¡æœ‰å¯æç¤ºçš„æ ¼å­ã€‚",
          "toast.hintUsed": "ä½¿ç”¨æç¤ºï¼Œå·²æ‰£åˆ†",
          "toast.noUndo": "æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œã€‚",
          "toast.undo": "å·²æ’¤é”€ä¸€æ­¥ã€‚",
          "toast.noRedo": "æ²¡æœ‰å¯é‡åšçš„æ“ä½œï¼ˆå…ˆæ’¤é”€ä¸€æ­¥ï¼‰ã€‚",
          "toast.redo": "å·²é‡åšä¸€æ­¥ã€‚",
          "toast.export.ok": "æ•°æ®å·²å¯¼å‡ºã€‚",
          "toast.export.fail": "å¯¼å‡ºå¤±è´¥ã€‚",
          "toast.import.badVersion": "å¯¼å…¥å¤±è´¥ï¼šç‰ˆæœ¬ä¸å…¼å®¹ã€‚",
          "toast.import.ok": "æ•°æ®å¯¼å…¥æˆåŠŸã€‚",
          "toast.import.fail": "å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶å†…å®¹æ— æ•ˆã€‚",
          "toast.share.system": "å·²è°ƒç”¨ç³»ç»Ÿåˆ†äº«ã€‚",
          "toast.share.copied": "è¿›åº¦é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚",
          "toast.share.fail": "åˆ†äº«å¤±è´¥ï¼Œå¯ç›´æ¥å¤åˆ¶åœ°å€æ é“¾æ¥ã€‚",
          "toast.daily.copied": "ä»Šæ—¥æŒ‘æˆ˜é“¾æ¥å·²å¤åˆ¶ã€‚",
          "toast.daily.copyFail": "å¤åˆ¶å¤±è´¥ã€‚",
          "toast.longPressNew": "å·²é•¿æŒ‰å¿«é€Ÿæ–°å¼€ã€‚",
          "toast.mute.on": "å·²é™éŸ³ã€‚",
          "toast.mute.off": "å·²å–æ¶ˆé™éŸ³ã€‚",
          "toast.contrast.on": "å·²å¼€å¯é«˜å¯¹æ¯”ã€‚",
          "toast.contrast.off": "å·²å…³é—­é«˜å¯¹æ¯”ã€‚",
          "toast.font.on": "å·²å¼€å¯å¤§å­—å·ã€‚",
          "toast.font.off": "å·²å…³é—­å¤§å­—å·ã€‚",
          "toast.effect": "ç‰¹æ•ˆå¼ºåº¦ï¼š{name}",
          "effect.low": "ä½",
          "effect.medium": "ä¸­",
          "effect.high": "é«˜",
          "confirm.new.desktop": "å½“å‰å¯¹å±€å°šæœªå®Œæˆï¼Œç¡®è®¤å¼€æ–°å±€ï¼Ÿ",
          "confirm.new.mobile": "çŸ­æŒ‰ä¼šäºŒæ¬¡ç¡®è®¤ï¼Œé•¿æŒ‰å¯ç›´æ¥æ–°å¼€ã€‚ç¡®è®¤ç°åœ¨æ–°å¼€å—ï¼Ÿ",
          "share.text": "æ¥ç©æˆ‘è¿™ç›˜æ•°ç‹¬ï¼ˆå«å½“å‰è¿›åº¦ï¼‰ï¼š{url}",
          "share.title": "æ•°ç‹¬æ´¾å¯¹ Pro",
          "share.invite": "è¿™ç›˜å¸ƒå±€æŒºæœ‰æ„æ€ï¼Œæ¥è¯•è¯•ï¼",
          "aria.fixed": "å›ºå®š",
          "aria.editable": "å¯ç¼–è¾‘",
          "aria.candidates": "å€™é€‰ {value}",
          "aria.empty": "ç©º",
          "aria.cell": "ç¬¬ {r} è¡Œç¬¬ {c} åˆ—ï¼Œ{fixed}ï¼Œå½“å‰ {value}",
          "title.win": "æ­å–œé€šå…³",
          "title.fail": "æœ¬å±€å¤±è´¥",
          "result.winReason": "ä½ å®Œæˆäº†æœ¬å±€æ•°ç‹¬ã€‚",
          "result.failReason": "æ‰£åˆ†è¾¾åˆ°å¤±è´¥é˜ˆå€¼ã€‚",
          "result.mode": "æ¨¡å¼ï¼š{mode}",
          "result.mode.daily": "æ¯æ—¥æŒ‘æˆ˜ {day}",
          "result.mode.normal": "æ™®é€š",
          "result.diff": "éš¾åº¦ï¼š{diff}",
          "result.time": "ç”¨æ—¶ï¼š{time}",
          "result.score": "å¾—åˆ†ï¼š{score}",
          "result.wrong": "é”™è¯¯æ¬¡æ•°ï¼š{n}",
          "result.hint": "æç¤ºæ¬¡æ•°ï¼š{n}",
          "result.candidate": "å€™é€‰ä½¿ç”¨æ¬¡æ•°ï¼š{n}",
          "result.rating": "éš¾åº¦è¯„åˆ†ï¼š{score}ï¼ˆè£¸å•å…ƒ {naked} / éšå•å…ƒ {hidden} / åŒºå—æ‘’é™¤ {locked}ï¼‰",
          "result.dailyRank": "ä»Šæ—¥æ’åï¼ˆæœ¬åœ°ï¼‰ï¼š#{n}",
        },
        en: {
          "app.title": "Sudoku Party Pro",
          "mode.normal": "Normal",
          "mode.daily": "Daily",
          "label.mode": "Mode: {mode}",
          "label.day": "Day: {day}",
          "label.timer": "Time: {time}",
          "label.score": "Score: {score}",
          "label.filled": "Filled: {filled}/81",
          "label.best.none": "Best: --:--",
          "label.best": "Best: {time} | {score} pts",
          "label.failThreshold": "Fail Threshold: {n}",
          "label.meta": "Difficulty: {diff} | Seed: {seed}",
          "leaderboard.normal": "Local Leaderboard (Top 5)",
          "leaderboard.daily": "Today's Leaderboard ({day}, Top 5)",
          "leaderboard.empty.normal": "No records yet. Be the first!",
          "leaderboard.empty.daily": "No scores yet today.",
          "btn.note": "Notes",
          "btn.undo": "Undo",
          "btn.redo": "Redo",
          "btn.erase": "Erase",
          "btn.hint": "Hint",
          "btn.newGame": "New Board",
          "btn.share": "Share Progress",
          "btn.settings": "Settings",
          "btn.copyDaily": "Copy Daily Link",
          "btn.autoCandidates": "Auto Candidates",
          "btn.clearCandidates": "Clear Candidates",
          "btn.mute": "Mute",
          "btn.contrast": "High Contrast",
          "btn.font": "Large Font",
          "btn.effect.low": "FX Low",
          "btn.effect.medium": "FX Medium",
          "btn.effect.high": "FX High",
          "btn.export": "Export Data",
          "btn.import": "Import Data",
          "btn.retry": "Play Again",
          "btn.close": "Close",
          "settings.title": "Settings",
          "label.volume": "Volume",
          "diff.easy": "Easy",
          "diff.medium": "Medium",
          "diff.hard": "Hard",
          "status.failed": "Score dropped below threshold. Game over.",
          "status.start": "Tap a cell to start.",
          "status.noteMode": "Notes mode is on. Select a cell and enter digits.",
          "status.fixed": "This is a fixed clue and cannot be edited.",
          "status.pos": "Row {r}, Col {c}{mode}",
          "status.pos.noteSuffix": " (notes mode)",
          "status.failWithAction": "Score dropped below threshold. Tap Play Again.",
          "toast.fail": "Game over: too many penalties.",
          "toast.autoCandidates.updated": "Auto candidates updated ({n} cells).",
          "toast.autoCandidates.latest": "Candidates are already up to date.",
          "toast.clearCandidates": "All candidates cleared.",
          "toast.restore": "Shared progress restored.",
          "toast.newPuzzle": "New puzzle is ready. Have fun!",
          "toast.noteUpdated": "Candidates updated.",
          "toast.wrong": "Wrong input, penalty applied",
          "toast.correct": "Correct input.",
          "toast.erased": "Cell erased.",
          "toast.noHint": "No hint available.",
          "toast.hintUsed": "Hint used, penalty applied",
          "toast.noUndo": "Nothing to undo.",
          "toast.undo": "Undo applied.",
          "toast.noRedo": "Nothing to redo (undo first).",
          "toast.redo": "Redo applied.",
          "toast.export.ok": "Data exported.",
          "toast.export.fail": "Export failed.",
          "toast.import.badVersion": "Import failed: incompatible version.",
          "toast.import.ok": "Data imported.",
          "toast.import.fail": "Import failed: invalid file.",
          "toast.share.system": "System share opened.",
          "toast.share.copied": "Progress link copied.",
          "toast.share.fail": "Share failed. Copy URL manually.",
          "toast.daily.copied": "Daily challenge link copied.",
          "toast.daily.copyFail": "Copy failed.",
          "toast.longPressNew": "Quick new board by long press.",
          "toast.mute.on": "Muted.",
          "toast.mute.off": "Unmuted.",
          "toast.contrast.on": "High contrast on.",
          "toast.contrast.off": "High contrast off.",
          "toast.font.on": "Large font on.",
          "toast.font.off": "Large font off.",
          "toast.effect": "Effect intensity: {name}",
          "effect.low": "Low",
          "effect.medium": "Medium",
          "effect.high": "High",
          "confirm.new.desktop": "Current game is not finished. Start a new board?",
          "confirm.new.mobile": "Tap asks confirmation; long press starts immediately. Start now?",
          "share.text": "Try my Sudoku board (with progress): {url}",
          "share.title": "Sudoku Party Pro",
          "share.invite": "This board is fun, give it a try!",
          "aria.fixed": "fixed",
          "aria.editable": "editable",
          "aria.candidates": "candidates {value}",
          "aria.empty": "empty",
          "aria.cell": "Row {r}, column {c}, {fixed}, current {value}",
          "title.win": "You Win",
          "title.fail": "Game Over",
          "result.winReason": "You solved this Sudoku board.",
          "result.failReason": "Penalty reached the fail threshold.",
          "result.mode": "Mode: {mode}",
          "result.mode.daily": "Daily {day}",
          "result.mode.normal": "Normal",
          "result.diff": "Difficulty: {diff}",
          "result.time": "Time: {time}",
          "result.score": "Score: {score}",
          "result.wrong": "Wrong entries: {n}",
          "result.hint": "Hints used: {n}",
          "result.candidate": "Candidate uses: {n}",
          "result.rating": "Difficulty score: {score} (Naked {naked} / Hidden {hidden} / Locked {locked})",
          "result.dailyRank": "Today's local rank: #{n}",
        },
      };

      const els = {
        body: document.body,
        board: document.getElementById("board"),
        numPad: document.getElementById("numPad"),
        difficultyRow: document.getElementById("difficultyRow"),
        status: document.getElementById("status"),
        toast: document.getElementById("toast"),
        meta: document.getElementById("meta"),
        modeBadge: document.getElementById("modeBadge"),
        dayBadge: document.getElementById("dayBadge"),
        timer: document.getElementById("timer"),
        score: document.getElementById("score"),
        filled: document.getElementById("filled"),
        best: document.getElementById("best"),
        danger: document.getElementById("danger"),
        leaderboard: document.getElementById("leaderboard"),
        leaderboardTitle: document.getElementById("leaderboardTitle"),
        noteMode: document.getElementById("noteMode"),
        autoCandidates: document.getElementById("autoCandidates"),
        clearCandidates: document.getElementById("clearCandidates"),
        undo: document.getElementById("undo"),
        redo: document.getElementById("redo"),
        erase: document.getElementById("erase"),
        hint: document.getElementById("hint"),
        newGame: document.getElementById("newGame"),
        share: document.getElementById("share"),
        toggleSettings: document.getElementById("toggleSettings"),
        settingsModal: document.getElementById("settingsModal"),
        settingsTitle: document.getElementById("settingsTitle"),
        settingsClose: document.getElementById("settingsClose"),
        settingsPanel: document.getElementById("settingsPanel"),
        modeNormal: document.getElementById("modeNormal"),
        modeDaily: document.getElementById("modeDaily"),
        copyDailyLink: document.getElementById("copyDailyLink"),
        langZh: document.getElementById("langZh"),
        langEn: document.getElementById("langEn"),
        muteBtn: document.getElementById("muteBtn"),
        contrastBtn: document.getElementById("contrastBtn"),
        fontBtn: document.getElementById("fontBtn"),
        effectRow: document.getElementById("effectRow"),
        volumeLabel: document.getElementById("volumeLabel"),
        volumeSlider: document.getElementById("volumeSlider"),
        volumeText: document.getElementById("volumeText"),
        exportData: document.getElementById("exportData"),
        importData: document.getElementById("importData"),
        importFile: document.getElementById("importFile"),
        resultModal: document.getElementById("resultModal"),
        resultTitle: document.getElementById("resultTitle"),
        resultBody: document.getElementById("resultBody"),
        resultRetry: document.getElementById("resultRetry"),
        resultClose: document.getElementById("resultClose"),
        fireworks: document.getElementById("fireworks"),
        victoryBanner: document.getElementById("victoryBanner"),
      };

      const GameState = {
        cells: [],
        solution: [],
        puzzle: [],
        state: [],
        fixed: [],
        notes: [],
        selected: -1,
        gameSeed: 0,
        difficulty: "medium",
        mode: "normal",
        day: "",
        startedAt: 0,
        elapsedSeconds: 0,
        timer: null,
        completed: false,
        failed: false,
        noteMode: false,
        settingsModalOpen: false,
        penaltyPoints: 0,
        score: Constants.START_SCORE,
        wrongCount: 0,
        hintCount: 0,
        candidateUseCount: 0,
        undoStack: [],
        redoStack: [],
        difficultyScore: 0,
        difficultyTech: { naked: 0, hidden: 0, locked: 0 },
        urlSyncTimer: null,
        lastUrlHash: "",
        longPressTimer: null,
        longPressTriggered: false,
        modalLastFocused: null,
      };

      const Settings = {
        mute: false,
        volume: 0.7,
        effectIntensity: "medium",
        highContrast: false,
        largeFont: false,
        language: "zh",
      };

      const AudioState = {
        ctx: null,
        ready: false,
      };

      const Effects = {
        ctx: els.fireworks.getContext("2d"),
      };

      function mulberry32(seed) {
        let a = seed >>> 0;
        return function () {
          a += 0x6d2b79f5;
          let t = a;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      function hashString(str) {
        let h = 2166136261;
        for (let i = 0; i < str.length; i += 1) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      function localToday() {
        const dtf = new Intl.DateTimeFormat("en-CA", { year: "numeric", month: "2-digit", day: "2-digit" });
        const parts = dtf.formatToParts(new Date());
        const y = parts.find((p) => p.type === "year").value;
        const m = parts.find((p) => p.type === "month").value;
        const d = parts.find((p) => p.type === "day").value;
        return `${y}-${m}-${d}`;
      }

      function fmtSec(s) {
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${String(m).padStart(2, "0")}:${String(sec).padStart(2, "0")}`;
      }

      function t(key, vars = {}) {
        const dict = I18N[Settings.language] || I18N.zh;
        let str = dict[key] ?? I18N.zh[key] ?? key;
        for (const [k, v] of Object.entries(vars)) {
          str = str.replaceAll(`{${k}}`, String(v));
        }
        return str;
      }

      function diffLabel(diffKey) {
        return t(`diff.${diffKey}`);
      }

      function setIconButtonText(el, icon, text) {
        el.textContent = "";
        const iconEl = document.createElement("span");
        iconEl.className = "btn-ico";
        iconEl.setAttribute("aria-hidden", "true");
        iconEl.textContent = icon;
        el.appendChild(iconEl);
        el.appendChild(document.createTextNode(text));
      }

      function toast(msg, ok = false) {
        els.toast.textContent = msg;
        els.toast.style.color = ok ? "#198754" : "#b23a48";
      }

      function setStatus(msg) {
        els.status.textContent = msg;
      }

      const Storage = {
        detectLanguage() {
          const lang = (navigator.language || "").toLowerCase();
          return lang.startsWith("zh") ? "zh" : "en";
        },
        readSettings() {
          try {
            const raw = localStorage.getItem(Constants.SETTINGS_KEY);
            if (!raw) {
              Settings.language = this.detectLanguage();
              return;
            }
            const data = JSON.parse(raw);
            if (typeof data.mute === "boolean") Settings.mute = data.mute;
            if (Number.isFinite(data.volume)) Settings.volume = Math.min(1, Math.max(0, data.volume));
            if (["low", "medium", "high"].includes(data.effectIntensity)) Settings.effectIntensity = data.effectIntensity;
            if (typeof data.highContrast === "boolean") Settings.highContrast = data.highContrast;
            if (typeof data.largeFont === "boolean") Settings.largeFont = data.largeFont;
            if (["zh", "en"].includes(data.language)) Settings.language = data.language;
            else Settings.language = this.detectLanguage();
          } catch {}
        },
        writeSettings() {
          try {
            localStorage.setItem(Constants.SETTINGS_KEY, JSON.stringify(Settings));
          } catch (err) {
            console.warn("Failed to persist settings:", err);
          }
        },
        readScores() {
          const base = { easy: [], medium: [], hard: [] };
          try {
            const raw = localStorage.getItem(Constants.SCORE_KEY);
            if (raw) {
              const parsed = JSON.parse(raw);
              for (const k of ["easy", "medium", "hard"]) {
                const list = Array.isArray(parsed[k]) ? parsed[k] : [];
                base[k] = list
                  .map((entry) => {
                    if (typeof entry === "number") return { time: Math.floor(entry), score: Constants.START_SCORE };
                    if (entry && Number.isFinite(entry.time) && Number.isFinite(entry.score)) {
                      return { time: Math.floor(entry.time), score: Math.floor(entry.score) };
                    }
                    return null;
                  })
                  .filter(Boolean)
                  .slice(0, 5);
              }
              return base;
            }
          } catch {}

          return base;
        },
        writeScores(scores) {
          try {
            localStorage.setItem(Constants.SCORE_KEY, JSON.stringify(scores));
          } catch (err) {
            console.warn("Failed to persist scores:", err);
          }
        },
        readDailyScores() {
          try {
            const raw = localStorage.getItem(Constants.DAILY_SCORE_KEY);
            if (!raw) return {};
            const parsed = JSON.parse(raw);
            return parsed && typeof parsed === "object" ? parsed : {};
          } catch {
            return {};
          }
        },
        writeDailyScores(data) {
          try {
            localStorage.setItem(Constants.DAILY_SCORE_KEY, JSON.stringify(data));
          } catch (err) {
            console.warn("Failed to persist daily scores:", err);
          }
        },
      };

      function ensureAudio() {
        if (Settings.mute) return false;
        if (!AudioState.ctx) {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return false;
          AudioState.ctx = new Ctx();
        }
        if (AudioState.ctx.state === "suspended") AudioState.ctx.resume();
        AudioState.ready = true;
        return true;
      }

      function playTone(freq, duration, type = "sine", volume = 0.05, when = 0) {
        if (Settings.mute) return;
        if (!AudioState.ready && !ensureAudio()) return;
        const now = AudioState.ctx.currentTime + when;
        const osc = AudioState.ctx.createOscillator();
        const gain = AudioState.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, now);
        const vol = volume * Settings.volume;
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.0002, vol), now + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.connect(gain);
        gain.connect(AudioState.ctx.destination);
        osc.start(now);
        osc.stop(now + duration + 0.03);
      }

      function playSfx(name) {
        if (Settings.mute) return;
        if (!AudioState.ready && !ensureAudio()) return;

        if (name === "fill-ok") {
          playTone(660, 0.09, "triangle", 0.04);
          playTone(880, 0.1, "triangle", 0.035, 0.06);
        } else if (name === "erase") {
          playTone(420, 0.06, "square", 0.03);
        } else if (name === "note") {
          playTone(720, 0.05, "sine", 0.02);
        } else if (name === "wrong") {
          playTone(220, 0.14, "sawtooth", 0.05);
          playTone(170, 0.12, "sawtooth", 0.04, 0.05);
        } else if (name === "hint") {
          playTone(540, 0.07, "triangle", 0.03);
          playTone(680, 0.08, "triangle", 0.03, 0.07);
        } else if (name === "undo") {
          playTone(500, 0.05, "sine", 0.02);
        } else if (name === "redo") {
          playTone(620, 0.05, "sine", 0.02);
        } else if (name === "fail") {
          playTone(210, 0.2, "sawtooth", 0.055);
          playTone(140, 0.22, "sawtooth", 0.05, 0.1);
        } else if (name === "win") {
          playTone(523, 0.09, "triangle", 0.04);
          playTone(659, 0.09, "triangle", 0.04, 0.1);
          playTone(784, 0.12, "triangle", 0.045, 0.2);
          playTone(1047, 0.16, "triangle", 0.045, 0.34);
        }
      }

      const Generator = {
        shuffle(arr, rand) {
          const out = arr.slice();
          for (let i = out.length - 1; i > 0; i -= 1) {
            const j = Math.floor(rand() * (i + 1));
            [out[i], out[j]] = [out[j], out[i]];
          }
          return out;
        },
        row(idx) { return Math.floor(idx / Constants.SIZE); },
        col(idx) { return idx % Constants.SIZE; },
        boxStartRow(r) { return Math.floor(r / Constants.BOX) * Constants.BOX; },
        boxStartCol(c) { return Math.floor(c / Constants.BOX) * Constants.BOX; },
        canPlace(grid, idx, n) {
          const r = this.row(idx);
          const c = this.col(idx);
          for (let i = 0; i < 9; i += 1) {
            if (grid[r * 9 + i] === n) return false;
            if (grid[i * 9 + c] === n) return false;
          }
          const br = this.boxStartRow(r);
          const bc = this.boxStartCol(c);
          for (let rr = br; rr < br + 3; rr += 1) {
            for (let cc = bc; cc < bc + 3; cc += 1) {
              if (grid[rr * 9 + cc] === n) return false;
            }
          }
          return true;
        },
        fill(rand, grid = new Array(81).fill(0), idx = 0) {
          while (idx < 81 && grid[idx] !== 0) idx += 1;
          if (idx === 81) return true;
          for (const n of this.shuffle(Constants.DIGITS, rand)) {
            if (!this.canPlace(grid, idx, n)) continue;
            grid[idx] = n;
            if (this.fill(rand, grid, idx + 1)) return true;
            grid[idx] = 0;
          }
          return false;
        },
        candidateMask(grid, idx) {
          if (grid[idx] !== 0) return 0;
          let mask = 0;
          for (let n = 1; n <= 9; n += 1) {
            if (this.canPlace(grid, idx, n)) mask |= 1 << (n - 1);
          }
          return mask;
        },
        bitCount(mask) {
          let x = mask;
          let c = 0;
          while (x) {
            x &= x - 1;
            c += 1;
          }
          return c;
        },
        firstBitDigit(mask) {
          for (let n = 1; n <= 9; n += 1) {
            if (mask & (1 << (n - 1))) return n;
          }
          return 0;
        },
        findBestCell(grid) {
          let bestIdx = -1;
          let bestMask = 0;
          let minCount = 10;
          for (let i = 0; i < 81; i += 1) {
            if (grid[i] !== 0) continue;
            const mask = this.candidateMask(grid, i);
            const cnt = this.bitCount(mask);
            if (cnt === 0) return { idx: i, mask: 0, count: 0 };
            if (cnt < minCount) {
              minCount = cnt;
              bestIdx = i;
              bestMask = mask;
              if (cnt === 1) break;
            }
          }
          return { idx: bestIdx, mask: bestMask, count: minCount };
        },
        countSolutions(grid, limit = 2) {
          let count = 0;
          const arr = grid.slice();
          const dfs = () => {
            if (count >= limit) return;
            const best = this.findBestCell(arr);
            if (best.idx === -1) {
              count += 1;
              return;
            }
            if (best.count === 0) return;

            for (let n = 1; n <= 9; n += 1) {
              const bit = 1 << (n - 1);
              if (!(best.mask & bit)) continue;
              arr[best.idx] = n;
              dfs();
              arr[best.idx] = 0;
              if (count >= limit) return;
            }
          };
          dfs();
          return count;
        },
        peers(index) {
          const r = this.row(index);
          const c = this.col(index);
          const set = new Set();
          for (let i = 0; i < 9; i += 1) {
            set.add(r * 9 + i);
            set.add(i * 9 + c);
          }
          const br = this.boxStartRow(r);
          const bc = this.boxStartCol(c);
          for (let rr = br; rr < br + 3; rr += 1) {
            for (let cc = bc; cc < bc + 3; cc += 1) set.add(rr * 9 + cc);
          }
          set.delete(index);
          return [...set];
        },
      };

      const Solver = {
        allUnits() {
          const units = [];
          for (let r = 0; r < 9; r += 1) units.push([...Array(9)].map((_, c) => r * 9 + c));
          for (let c = 0; c < 9; c += 1) units.push([...Array(9)].map((_, r) => r * 9 + c));
          for (let br = 0; br < 3; br += 1) {
            for (let bc = 0; bc < 3; bc += 1) {
              const u = [];
              for (let r = br * 3; r < br * 3 + 3; r += 1) {
                for (let c = bc * 3; c < bc * 3 + 3; c += 1) u.push(r * 9 + c);
              }
              units.push(u);
            }
          }
          return units;
        },
        solveAndRate(puzzle) {
          const grid = puzzle.slice();
          const notes = new Array(81).fill(0);
          const stats = { naked: 0, hidden: 0, locked: 0 };
          const units = this.allUnits();

          const computeAllNotes = () => {
            for (let i = 0; i < 81; i += 1) {
              notes[i] = grid[i] === 0 ? Generator.candidateMask(grid, i) : 0;
            }
          };

          const setCell = (idx, n, kind) => {
            grid[idx] = n;
            notes[idx] = 0;
            if (kind && stats[kind] !== undefined) stats[kind] += 1;
          };

          const applyNakedSingle = () => {
            for (let i = 0; i < 81; i += 1) {
              if (grid[i] !== 0) continue;
              const m = notes[i];
              if (m && Generator.bitCount(m) === 1) {
                setCell(i, Generator.firstBitDigit(m), "naked");
                return true;
              }
            }
            return false;
          };

          const applyHiddenSingle = () => {
            for (const unit of units) {
              for (let n = 1; n <= 9; n += 1) {
                const bit = 1 << (n - 1);
                let pos = -1;
                let cnt = 0;
                for (const idx of unit) {
                  if (grid[idx] === 0 && (notes[idx] & bit)) {
                    cnt += 1;
                    pos = idx;
                    if (cnt > 1) break;
                  }
                }
                if (cnt === 1) {
                  setCell(pos, n, "hidden");
                  return true;
                }
              }
            }
            return false;
          };

          const applyLockedCandidates = () => {
            for (let br = 0; br < 3; br += 1) {
              for (let bc = 0; bc < 3; bc += 1) {
                const box = [];
                for (let r = br * 3; r < br * 3 + 3; r += 1) {
                  for (let c = bc * 3; c < bc * 3 + 3; c += 1) box.push(r * 9 + c);
                }
                for (let n = 1; n <= 9; n += 1) {
                  const bit = 1 << (n - 1);
                  const holders = box.filter((idx) => grid[idx] === 0 && (notes[idx] & bit));
                  if (holders.length <= 1) continue;
                  const rows = new Set(holders.map((idx) => Math.floor(idx / 9)));
                  const cols = new Set(holders.map((idx) => idx % 9));

                  if (rows.size === 1) {
                    const row = [...rows][0];
                    let changed = false;
                    for (let c = 0; c < 9; c += 1) {
                      const idx = row * 9 + c;
                      if (box.includes(idx) || grid[idx] !== 0) continue;
                      if (notes[idx] & bit) {
                        notes[idx] &= ~bit;
                        changed = true;
                      }
                    }
                    if (changed) {
                      stats.locked += 1;
                      return true;
                    }
                  }

                  if (cols.size === 1) {
                    const col = [...cols][0];
                    let changed = false;
                    for (let r = 0; r < 9; r += 1) {
                      const idx = r * 9 + col;
                      if (box.includes(idx) || grid[idx] !== 0) continue;
                      if (notes[idx] & bit) {
                        notes[idx] &= ~bit;
                        changed = true;
                      }
                    }
                    if (changed) {
                      stats.locked += 1;
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          };

          computeAllNotes();
          let guard = 0;
          while (guard < 1000) {
            guard += 1;
            if (!grid.includes(0)) break;
            if (applyNakedSingle()) {
              computeAllNotes();
              continue;
            }
            if (applyHiddenSingle()) {
              computeAllNotes();
              continue;
            }
            if (applyLockedCandidates()) {
              continue;
            }
            break;
          }

          const solved = !grid.includes(0);
          const difficultyScore = stats.naked * 1 + stats.hidden * 2 + stats.locked * 7;
          return { solved, difficultyScore, stats };
        },
        classify(result) {
          const { difficultyScore, stats } = result;
          if (stats.locked === 0 && difficultyScore <= 30) return "easy";
          if (difficultyScore <= 80 && stats.locked <= 4) return "medium";
          return "hard";
        },
      };

      const Scoring = {
        recompute() {
          GameState.score = Math.max(0, Constants.START_SCORE - GameState.penaltyPoints);
          els.score.textContent = t("label.score", { score: GameState.score });
          els.danger.textContent = t("label.failThreshold", { n: Constants.FAIL_THRESHOLD });
        },
      };

      const UI = {
        applyLanguageTexts() {
          document.documentElement.lang = Settings.language === "en" ? "en" : "zh-CN";
          document.title = t("app.title");
          els.victoryBanner.textContent = Settings.language === "en" ? "Perfect! Sudoku Cleared" : "Perfect! æ•°ç‹¬é€šå…³";
          const title = document.querySelector("h1");
          if (title) title.textContent = t("app.title");

          setIconButtonText(els.noteMode, "âœ", t("btn.note"));
          setIconButtonText(els.undo, "â†¶", t("btn.undo"));
          setIconButtonText(els.redo, "â†·", t("btn.redo"));
          setIconButtonText(els.erase, "âŒ«", t("btn.erase"));
          setIconButtonText(els.hint, "ğŸ’¡", t("btn.hint"));
          setIconButtonText(els.newGame, "âŸ³", t("btn.newGame"));
          setIconButtonText(els.share, "ğŸ”—", t("btn.share"));
          setIconButtonText(els.toggleSettings, "âš™", t("btn.settings"));
          setIconButtonText(els.copyDailyLink, "ğŸ”—", t("btn.copyDaily"));
          setIconButtonText(els.autoCandidates, "âš™", t("btn.autoCandidates"));
          setIconButtonText(els.clearCandidates, "âŠ˜", t("btn.clearCandidates"));
          setIconButtonText(els.muteBtn, "ğŸ”Š", t("btn.mute"));
          setIconButtonText(els.contrastBtn, "â—", t("btn.contrast"));
          setIconButtonText(els.fontBtn, "A+", t("btn.font"));
          setIconButtonText(els.exportData, "â¬‡", t("btn.export"));
          setIconButtonText(els.importData, "â¬†", t("btn.import"));

          els.modeNormal.textContent = t("mode.normal");
          els.modeDaily.textContent = t("mode.daily");
          els.langZh.textContent = "ä¸­æ–‡";
          els.langEn.textContent = "English";
          els.resultRetry.textContent = t("btn.retry");
          els.resultClose.textContent = t("btn.close");
          els.settingsTitle.textContent = t("settings.title");
          els.settingsClose.textContent = t("btn.close");
          els.volumeLabel.textContent = t("label.volume");

          for (const btn of els.effectRow.querySelectorAll("button")) {
            const level = btn.dataset.effect;
            btn.textContent = t(`btn.effect.${level}`);
          }
        },
        applySettings() {
          this.applyLanguageTexts();
          els.body.classList.toggle("high-contrast", Settings.highContrast);
          els.body.classList.toggle("large-font", Settings.largeFont);
          els.muteBtn.classList.toggle("active", Settings.mute);
          els.muteBtn.setAttribute("aria-pressed", String(Settings.mute));
          els.contrastBtn.classList.toggle("active", Settings.highContrast);
          els.contrastBtn.setAttribute("aria-pressed", String(Settings.highContrast));
          els.fontBtn.classList.toggle("active", Settings.largeFont);
          els.fontBtn.setAttribute("aria-pressed", String(Settings.largeFont));
          els.langZh.classList.toggle("active", Settings.language === "zh");
          els.langEn.classList.toggle("active", Settings.language === "en");
          els.volumeSlider.value = String(Settings.volume);
          els.volumeText.textContent = `${Math.round(Settings.volume * 100)}%`;
          for (const btn of els.effectRow.querySelectorAll("button")) {
            btn.classList.toggle("active", btn.dataset.effect === Settings.effectIntensity);
          }
        },
        updateTimer() {
          els.timer.textContent = t("label.timer", { time: fmtSec(GameState.elapsedSeconds) });
        },
        updateBadges() {
          const modeText = GameState.mode === "daily" ? t("mode.daily") : t("mode.normal");
          els.modeBadge.textContent = t("label.mode", { mode: modeText });
          els.dayBadge.textContent = t("label.day", { day: GameState.day || "--" });
          els.meta.textContent = t("label.meta", { diff: diffLabel(GameState.difficulty), seed: GameState.gameSeed });
          els.modeNormal.classList.toggle("active", GameState.mode === "normal");
          els.modeDaily.classList.toggle("active", GameState.mode === "daily");
        },
        updateProgress() {
          const filled = GameState.state.filter((v) => v !== 0).length;
          els.filled.textContent = t("label.filled", { filled });
        },
        renderDifficultyButtons() {
          for (const btn of els.difficultyRow.querySelectorAll("button")) {
            btn.classList.toggle("active", btn.dataset.diff === GameState.difficulty);
          }
        },
        renderActionButtons() {
          els.noteMode.classList.toggle("active", GameState.noteMode);
          els.noteMode.setAttribute("aria-pressed", String(GameState.noteMode));
          els.undo.disabled = GameState.undoStack.length === 0;
          els.redo.disabled = GameState.redoStack.length === 0;
          els.undo.title = t("btn.undo");
          els.redo.title = t("btn.redo");
          els.toggleSettings.classList.toggle("active", GameState.settingsModalOpen);
          els.toggleSettings.setAttribute("aria-expanded", String(GameState.settingsModalOpen));
        },
        noteDigits(mask) {
          let out = "";
          for (let n = 1; n <= 9; n += 1) {
            if (mask & (1 << (n - 1))) out += String(n);
          }
          return out;
        },
        setCellAria(cell, i) {
          const r = Math.floor(i / 9) + 1;
          const c = (i % 9) + 1;
          const fixed = GameState.fixed[i] ? t("aria.fixed") : t("aria.editable");
          const value = GameState.state[i] || (GameState.notes[i] ? t("aria.candidates", { value: this.noteDigits(GameState.notes[i]) }) : t("aria.empty"));
          cell.setAttribute("aria-label", t("aria.cell", { r, c, fixed, value }));
        },
        renderBoard() {
          const bad = new Set();
          for (let i = 0; i < 81; i += 1) {
            if (GameState.state[i] === 0) continue;
            const v = GameState.state[i];
            for (const p of Generator.peers(i)) {
              if (GameState.state[p] === v) {
                bad.add(i);
                bad.add(p);
              }
            }
          }

          const peerSet = GameState.selected >= 0 ? new Set(Generator.peers(GameState.selected)) : new Set();

          GameState.cells.forEach((cell, i) => {
            cell.className = "cell";
            if (GameState.fixed[i]) cell.classList.add("fixed");
            else if (GameState.state[i] !== 0) cell.classList.add("input");

            if (GameState.selected === i) cell.classList.add("selected");
            else if (peerSet.has(i)) cell.classList.add("peer");
            if (bad.has(i)) cell.classList.add("conflict");
            if (!bad.has(i) && GameState.state[i] !== 0 && GameState.state[i] === GameState.solution[i]) {
              cell.classList.add("good");
            }

            if (GameState.state[i] !== 0) {
              cell.textContent = String(GameState.state[i]);
            } else if (GameState.notes[i] !== 0) {
              cell.classList.add("note");
              cell.textContent = this.noteDigits(GameState.notes[i]);
            } else {
              cell.textContent = "";
            }

            this.setCellAria(cell, i);
          });

          this.renderActionButtons();
          this.updateProgress();
          Scoring.recompute();
          URLSync.schedule();

          if (GameState.failed) {
            setStatus(t("status.failed"));
          } else if (GameState.selected < 0) {
            setStatus(GameState.noteMode ? t("status.noteMode") : t("status.start"));
          } else if (GameState.fixed[GameState.selected]) {
            setStatus(t("status.fixed"));
          } else {
            const rr = Math.floor(GameState.selected / 9) + 1;
            const cc = (GameState.selected % 9) + 1;
            setStatus(t("status.pos", { r: rr, c: cc, mode: GameState.noteMode ? t("status.pos.noteSuffix") : "" }));
          }

          if (!GameState.completed && !GameState.failed && checkWin()) {
            Game.complete();
          }
        },
        renderLeaderboard() {
          els.leaderboard.innerHTML = "";
          if (GameState.mode === "daily") {
            const dayKey = `${GameState.day}:${GameState.difficulty}`;
            const map = Storage.readDailyScores();
            const list = Array.isArray(map[dayKey]) ? map[dayKey] : [];
            els.leaderboardTitle.textContent = t("leaderboard.daily", { day: GameState.day });
            if (list.length === 0) {
              const li = document.createElement("li");
              li.textContent = t("leaderboard.empty.daily");
              els.leaderboard.appendChild(li);
              els.best.textContent = t("label.best.none");
              return;
            }
            list.forEach((e, i) => {
              const li = document.createElement("li");
              li.textContent = `#${i + 1} ${fmtSec(e.time)} | ${e.score}`;
              els.leaderboard.appendChild(li);
            });
            els.best.textContent = t("label.best", { time: fmtSec(list[0].time), score: list[0].score });
            return;
          }

          const scores = Storage.readScores();
          const list = scores[GameState.difficulty] || [];
          els.leaderboardTitle.textContent = t("leaderboard.normal");
          if (list.length === 0) {
            const li = document.createElement("li");
            li.textContent = t("leaderboard.empty.normal");
            els.leaderboard.appendChild(li);
            els.best.textContent = t("label.best.none");
            return;
          }
          list.forEach((e, i) => {
            const li = document.createElement("li");
            li.textContent = `#${i + 1} ${fmtSec(e.time)} | ${e.score}`;
            els.leaderboard.appendChild(li);
          });
          els.best.textContent = t("label.best", { time: fmtSec(list[0].time), score: list[0].score });
        },
        openResultModal(title, lines) {
          if (GameState.settingsModalOpen) this.closeSettingsModal(false);
          GameState.modalLastFocused = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          els.resultTitle.textContent = title;
          els.resultBody.textContent = "";
          for (const line of lines) {
            const p = document.createElement("p");
            p.textContent = line;
            els.resultBody.appendChild(p);
          }
          els.resultModal.classList.add("open");
          document.body.style.overflow = "hidden";
          requestAnimationFrame(() => {
            els.resultRetry.focus();
          });
        },
        modalFocusableElements(modalEl) {
          return Array.from(
            modalEl.querySelectorAll(
              'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            )
          ).filter((node) => !node.hasAttribute("disabled"));
        },
        trapFocus(e, modalEl) {
          const focusables = this.modalFocusableElements(modalEl);
          if (focusables.length === 0) return;
          const first = focusables[0];
          const last = focusables[focusables.length - 1];
          const active = document.activeElement;
          if (!focusables.includes(active)) {
            e.preventDefault();
            (e.shiftKey ? last : first).focus();
            return;
          }
          if (e.shiftKey && active === first) {
            e.preventDefault();
            last.focus();
            return;
          }
          if (!e.shiftKey && active === last) {
            e.preventDefault();
            first.focus();
            return;
          }
        },
        closeResultModal() {
          els.resultModal.classList.remove("open");
          document.body.style.overflow = "";
          if (GameState.modalLastFocused && typeof GameState.modalLastFocused.focus === "function") {
            GameState.modalLastFocused.focus();
          }
          GameState.modalLastFocused = null;
        },
        openSettingsModal() {
          if (els.resultModal.classList.contains("open")) this.closeResultModal();
          GameState.settingsModalOpen = true;
          els.settingsModal.classList.add("open");
          document.body.style.overflow = "hidden";
          this.renderActionButtons();
          requestAnimationFrame(() => {
            els.settingsClose.focus();
          });
        },
        closeSettingsModal(restoreFocus = true) {
          GameState.settingsModalOpen = false;
          els.settingsModal.classList.remove("open");
          document.body.style.overflow = "";
          this.renderActionButtons();
          if (restoreFocus) els.toggleSettings.focus();
        },
      };

      const URLSync = {
        encodeState(arr) { return arr.map((n) => String(n)).join(""); },
        decodeState(text) {
          if (!text || text.length !== 81 || !/^[0-9]+$/.test(text)) return null;
          return text.split("").map((c) => Number(c));
        },
        encodeNotes(arr) {
          return arr.map((n) => n.toString(36).padStart(2, "0")).join("");
        },
        decodeNotes(text) {
          if (!text || text.length !== 162 || !/^[0-9a-z]+$/.test(text)) return null;
          const out = [];
          for (let i = 0; i < 162; i += 2) {
            const val = Number.parseInt(text.slice(i, i + 2), 36);
            if (!Number.isFinite(val) || val < 0 || val > 511) return null;
            out.push(val);
          }
          return out;
        },
        makeURL() {
          const url = new URL(window.location.href);
          url.searchParams.set("v", Constants.URL_VERSION);
          url.searchParams.set("seed", String(GameState.gameSeed));
          url.searchParams.set("diff", GameState.difficulty);
          url.searchParams.set("mode", GameState.mode);
          url.searchParams.set("day", GameState.day);
          url.searchParams.set("state", this.encodeState(GameState.state));
          url.searchParams.set("notes", this.encodeNotes(GameState.notes));
          url.searchParams.set("t", String(GameState.elapsedSeconds));
          url.searchParams.set("p", String(GameState.penaltyPoints));
          return url;
        },
        flush(force = false) {
          if (GameState.urlSyncTimer) {
            clearTimeout(GameState.urlSyncTimer);
            GameState.urlSyncTimer = null;
          }
          const url = this.makeURL();
          const hash = url.search;
          if (!force && hash === GameState.lastUrlHash) return;
          history.replaceState({}, "", url);
          GameState.lastUrlHash = hash;
        },
        schedule() {
          if (GameState.urlSyncTimer) return;
          GameState.urlSyncTimer = setTimeout(() => {
            GameState.urlSyncTimer = null;
            this.flush(false);
          }, 300);
        },
      };

      function resizeFireworks() {
        els.fireworks.width = window.innerWidth;
        els.fireworks.height = window.innerHeight;
      }

      function vibrateWarn() {
        if (navigator.vibrate) navigator.vibrate([120, 50, 120]);
        els.board.classList.remove("shake");
        void els.board.offsetWidth;
        els.board.classList.add("shake");
      }

      function effectConfig() {
        if (Settings.effectIntensity === "low") return { bursts: 4, confetti: 80, frames: 100 };
        if (Settings.effectIntensity === "high") return { bursts: 12, confetti: 260, frames: 220 };
        return { bursts: 8, confetti: 160, frames: 160 };
      }

      function launchFireworks() {
        const cfg = effectConfig();
        const colors = ["#ff595e", "#ffca3a", "#8ac926", "#1982c4", "#6a4c93", "#ff924c"];
        const particles = [];
        const confetti = [];

        els.body.classList.add("victory-flash");
        els.victoryBanner.classList.remove("show");
        void els.victoryBanner.offsetWidth;
        els.victoryBanner.classList.add("show");
        setTimeout(() => {
          els.body.classList.remove("victory-flash");
          els.victoryBanner.classList.remove("show");
        }, 1800);

        for (let b = 0; b < cfg.bursts; b += 1) {
          const cx = Math.random() * els.fireworks.width;
          const cy = Math.random() * (els.fireworks.height * 0.55);
          const count = 38;
          for (let i = 0; i < count; i += 1) {
            const angle = (Math.PI * 2 * i) / count;
            const speed = 1 + Math.random() * 4;
            particles.push({ x: cx, y: cy, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 70 + Math.floor(Math.random() * 30), color: colors[Math.floor(Math.random() * colors.length)] });
          }
        }

        for (let i = 0; i < cfg.confetti; i += 1) {
          confetti.push({
            x: Math.random() * els.fireworks.width,
            y: -Math.random() * els.fireworks.height * 0.35,
            vx: -1 + Math.random() * 2,
            vy: 1.4 + Math.random() * 2.4,
            w: 4 + Math.random() * 4,
            h: 8 + Math.random() * 8,
            rot: Math.random() * Math.PI,
            vr: -0.1 + Math.random() * 0.2,
            color: colors[Math.floor(Math.random() * colors.length)],
          });
        }

        let frame = 0;
        function step() {
          frame += 1;
          Effects.ctx.clearRect(0, 0, els.fireworks.width, els.fireworks.height);

          for (const p of particles) {
            if (p.life <= 0) continue;
            p.life -= 1;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.04;
            Effects.ctx.globalAlpha = Math.max(0, p.life / 100);
            Effects.ctx.fillStyle = p.color;
            Effects.ctx.beginPath();
            Effects.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            Effects.ctx.fill();
          }

          for (const c of confetti) {
            c.x += c.vx;
            c.y += c.vy;
            c.rot += c.vr;
            Effects.ctx.save();
            Effects.ctx.translate(c.x, c.y);
            Effects.ctx.rotate(c.rot);
            Effects.ctx.fillStyle = c.color;
            Effects.ctx.globalAlpha = frame < cfg.frames * 0.6 ? 0.85 : Math.max(0, (cfg.frames - frame) / (cfg.frames * 0.4));
            Effects.ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);
            Effects.ctx.restore();
          }

          Effects.ctx.globalAlpha = 1;
          if (frame < cfg.frames) requestAnimationFrame(step);
          else Effects.ctx.clearRect(0, 0, els.fireworks.width, els.fireworks.height);
        }

        requestAnimationFrame(step);
      }

      function startTimer(fromSeconds = 0) {
        if (GameState.timer) clearInterval(GameState.timer);
        GameState.elapsedSeconds = fromSeconds;
        GameState.startedAt = Date.now() - fromSeconds * 1000;
        UI.updateTimer();
        GameState.timer = setInterval(() => {
          if (!GameState.startedAt || GameState.completed || GameState.failed) return;
          GameState.elapsedSeconds = Math.floor((Date.now() - GameState.startedAt) / 1000);
          UI.updateTimer();
          URLSync.schedule();
        }, 1000);
      }

      function stopTimer() {
        if (GameState.timer) {
          clearInterval(GameState.timer);
          GameState.timer = null;
        }
      }

      function checkWin() {
        if (GameState.state.includes(0)) return false;
        for (let i = 0; i < 81; i += 1) {
          if (GameState.state[i] !== GameState.solution[i]) return false;
        }
        return true;
      }

      function snapshot() {
        return {
          state: GameState.state.slice(),
          notes: GameState.notes.slice(),
          penaltyPoints: GameState.penaltyPoints,
          elapsedSeconds: GameState.elapsedSeconds,
          completed: GameState.completed,
          failed: GameState.failed,
          selected: GameState.selected,
          wrongCount: GameState.wrongCount,
          hintCount: GameState.hintCount,
          candidateUseCount: GameState.candidateUseCount,
        };
      }

      function saveHistory() {
        GameState.undoStack.push(snapshot());
        if (GameState.undoStack.length > 200) GameState.undoStack.shift();
        GameState.redoStack = [];
      }

      function restoreSnapshot(snap) {
        GameState.state = snap.state.slice();
        GameState.notes = snap.notes.slice();
        GameState.penaltyPoints = snap.penaltyPoints;
        GameState.elapsedSeconds = snap.elapsedSeconds;
        GameState.completed = snap.completed;
        GameState.failed = snap.failed;
        GameState.selected = snap.selected;
        GameState.wrongCount = snap.wrongCount;
        GameState.hintCount = snap.hintCount;
        GameState.candidateUseCount = snap.candidateUseCount;
        Scoring.recompute();
        if (!GameState.completed && !GameState.failed) startTimer(GameState.elapsedSeconds);
        else stopTimer();
        UI.renderBoard();
      }

      function pushNormalScore(diff, sec, score) {
        const scores = Storage.readScores();
        const list = scores[diff] || [];
        list.push({ time: sec, score });
        list.sort((a, b) => (a.time !== b.time ? a.time - b.time : b.score - a.score));
        scores[diff] = list.slice(0, 5);
        Storage.writeScores(scores);
      }

      function pushDailyScore(day, diff, sec, score) {
        const all = Storage.readDailyScores();
        const key = `${day}:${diff}`;
        const list = Array.isArray(all[key]) ? all[key] : [];
        list.push({ time: sec, score });
        list.sort((a, b) => (a.time !== b.time ? a.time - b.time : b.score - a.score));
        all[key] = list.slice(0, 5);
        Storage.writeDailyScores(all);
        return all[key];
      }

      function applyPenalty(points, msg, sfx = "wrong") {
        GameState.penaltyPoints += points;
        Scoring.recompute();
        vibrateWarn();
        playSfx(sfx);
        toast(`${msg} (-${points})`, false);
        if (!GameState.failed && GameState.score <= Constants.FAIL_THRESHOLD) {
          GameState.failed = true;
          stopTimer();
          playSfx("fail");
          setStatus(t("status.failWithAction"));
          toast(t("toast.fail"), false);
          Game.openResult(false);
        }
      }

      function clearDigitFromPeers(idx, digit) {
        const bit = 1 << (digit - 1);
        for (const p of Generator.peers(idx)) {
          GameState.notes[p] &= ~bit;
        }
      }

      function autoCandidates() {
        saveHistory();
        let touched = 0;
        for (let i = 0; i < 81; i += 1) {
          if (GameState.state[i] !== 0 || GameState.fixed[i]) continue;
          const mask = Generator.candidateMask(GameState.state, i);
          const prev = GameState.notes[i];
          GameState.notes[i] = prev | mask;
          if (GameState.notes[i] !== prev) touched += 1;
        }
        GameState.candidateUseCount += 1;
        playSfx("note");
        toast(touched > 0 ? t("toast.autoCandidates.updated", { n: touched }) : t("toast.autoCandidates.latest"), true);
        UI.renderBoard();
      }

      function clearCandidates() {
        saveHistory();
        GameState.notes = new Array(81).fill(0);
        playSfx("erase");
        toast(t("toast.clearCandidates"), true);
        UI.renderBoard();
      }

      const Game = {
        generatePuzzle(seed, targetDiff) {
          const target = DIFFICULTIES[targetDiff];
          const randBase = mulberry32(seed);
          let best = null;

          for (let attempt = 0; attempt < 12; attempt += 1) {
            const full = new Array(81).fill(0);
            const rand = mulberry32(((seed ^ (attempt * 2654435761)) + Math.floor(randBase() * 1e9)) >>> 0);
            Generator.fill(rand, full, 0);

            const puzzle = full.slice();
            const indexes = Generator.shuffle([...Array(81).keys()], rand);
            let removed = 0;
            let guard = 0;

            for (const idx of indexes) {
              if (removed >= target.holes || guard > 600) break;
              guard += 1;
              const old = puzzle[idx];
              if (old === 0) continue;
              puzzle[idx] = 0;
              const solutions = Generator.countSolutions(puzzle, 2);
              if (solutions === 1) removed += 1;
              else puzzle[idx] = old;
            }

            const rating = Solver.solveAndRate(puzzle);
            const gotDiff = Solver.classify(rating);
            const cand = {
              solved: full,
              puzzle,
              score: rating.difficultyScore,
              tech: rating.stats,
              gotDiff,
              diffDistance: Math.abs(rating.difficultyScore - target.target),
            };

            if (!best || cand.diffDistance < best.diffDistance) best = cand;
            if (gotDiff === targetDiff) return cand;
          }

          return best;
        },
        load(seed, options = {}) {
          GameState.gameSeed = seed >>> 0;
          const gen = this.generatePuzzle(GameState.gameSeed, GameState.difficulty);
          GameState.solution = gen.solved;
          GameState.puzzle = gen.puzzle;
          GameState.state = gen.puzzle.slice();
          GameState.fixed = gen.puzzle.map((v) => v !== 0);
          GameState.notes = new Array(81).fill(0);
          GameState.selected = -1;
          GameState.completed = false;
          GameState.failed = false;
          GameState.noteMode = false;
          GameState.undoStack = [];
          GameState.redoStack = [];
          GameState.wrongCount = 0;
          GameState.hintCount = 0;
          GameState.candidateUseCount = 0;
          GameState.difficultyScore = gen.score;
          GameState.difficultyTech = gen.tech;
          els.body.classList.remove("victory-flash");
          els.victoryBanner.classList.remove("show");

          if (Array.isArray(options.progress) && options.progress.length === 81) {
            for (let i = 0; i < 81; i += 1) {
              if (!GameState.fixed[i] && options.progress[i] >= 0 && options.progress[i] <= 9) GameState.state[i] = options.progress[i];
            }
          }
          if (Array.isArray(options.notes) && options.notes.length === 81) {
            for (let i = 0; i < 81; i += 1) {
              if (!GameState.fixed[i] && GameState.state[i] === 0) GameState.notes[i] = options.notes[i] & 511;
            }
          }

          GameState.penaltyPoints = Number.isFinite(options.penaltyPoints) && options.penaltyPoints >= 0 ? Math.floor(options.penaltyPoints) : 0;
          Scoring.recompute();

          const initialSeconds = Number.isFinite(options.elapsed) && options.elapsed >= 0 ? Math.floor(options.elapsed) : 0;
          if (GameState.score <= Constants.FAIL_THRESHOLD) {
            GameState.failed = true;
            GameState.elapsedSeconds = initialSeconds;
            UI.updateTimer();
            stopTimer();
          } else {
            startTimer(initialSeconds);
          }

          UI.updateBadges();
          UI.renderDifficultyButtons();
          UI.renderLeaderboard();
          UI.renderBoard();
          toast(options.restore ? t("toast.restore") : t("toast.newPuzzle"), true);
        },
        complete() {
          GameState.completed = true;
          GameState.elapsedSeconds = Math.floor((Date.now() - GameState.startedAt) / 1000);
          stopTimer();
          playSfx("win");
          launchFireworks();

          if (GameState.mode === "daily") {
            const list = pushDailyScore(GameState.day, GameState.difficulty, GameState.elapsedSeconds, GameState.score);
            UI.renderLeaderboard();
            const rank = list.findIndex((x) => x.time === GameState.elapsedSeconds && x.score === GameState.score) + 1;
            this.openResult(true, rank);
          } else {
            pushNormalScore(GameState.difficulty, GameState.elapsedSeconds, GameState.score);
            UI.renderLeaderboard();
            this.openResult(true, null);
          }
          URLSync.flush(true);
        },
        openResult(win, dailyRank) {
          const title = win ? t("title.win") : t("title.fail");
          const reason = win ? t("result.winReason") : t("result.failReason");
          const lines = [
            reason,
            t("result.mode", { mode: GameState.mode === "daily" ? t("result.mode.daily", { day: GameState.day }) : t("result.mode.normal") }),
            t("result.diff", { diff: diffLabel(GameState.difficulty) }),
            t("result.time", { time: fmtSec(GameState.elapsedSeconds) }),
            t("result.score", { score: GameState.score }),
            t("result.wrong", { n: GameState.wrongCount }),
            t("result.hint", { n: GameState.hintCount }),
            t("result.candidate", { n: GameState.candidateUseCount }),
            t("result.rating", {
              score: GameState.difficultyScore,
              naked: GameState.difficultyTech.naked,
              hidden: GameState.difficultyTech.hidden,
              locked: GameState.difficultyTech.locked,
            }),
          ];
          if (GameState.mode === "daily" && dailyRank) lines.push(t("result.dailyRank", { n: dailyRank }));
          UI.openResultModal(title, lines);
        },
      };

      function toggleNote(index, n) {
        const bit = 1 << (n - 1);
        GameState.notes[index] ^= bit;
      }

      function writeNumber(n) {
        if (GameState.selected < 0 || GameState.fixed[GameState.selected] || GameState.completed || GameState.failed) return;
        saveHistory();

        if (GameState.noteMode && GameState.state[GameState.selected] === 0) {
          toggleNote(GameState.selected, n);
          GameState.candidateUseCount += 1;
          playSfx("note");
          toast(t("toast.noteUpdated"), true);
          UI.renderBoard();
          return;
        }

        if (GameState.solution[GameState.selected] !== n) {
          GameState.wrongCount += 1;
          applyPenalty(Constants.WRONG_PENALTY, t("toast.wrong"), "wrong");
          UI.renderBoard();
          return;
        }

        GameState.state[GameState.selected] = n;
        GameState.notes[GameState.selected] = 0;
        clearDigitFromPeers(GameState.selected, n);
        playSfx("fill-ok");
        toast(t("toast.correct"), true);
        UI.renderBoard();
      }

      function erase() {
        if (GameState.selected < 0 || GameState.fixed[GameState.selected] || GameState.completed || GameState.failed) return;
        saveHistory();
        GameState.state[GameState.selected] = 0;
        GameState.notes[GameState.selected] = 0;
        playSfx("erase");
        toast(t("toast.erased"), true);
        UI.renderBoard();
      }

      function giveHint() {
        if (GameState.completed || GameState.failed) return;
        const editable = [...Array(81).keys()].filter((i) => !GameState.fixed[i] && GameState.state[i] !== GameState.solution[i]);
        if (editable.length === 0) {
          toast(t("toast.noHint"), true);
          return;
        }
        saveHistory();
        const idx = editable[Math.floor(Math.random() * editable.length)];
        GameState.state[idx] = GameState.solution[idx];
        GameState.notes[idx] = 0;
        clearDigitFromPeers(idx, GameState.solution[idx]);
        GameState.selected = idx;
        GameState.hintCount += 1;
        applyPenalty(Constants.HINT_PENALTY, t("toast.hintUsed"), "hint");
        UI.renderBoard();
      }

      function undo() {
        if (GameState.undoStack.length === 0) {
          toast(t("toast.noUndo"), false);
          return;
        }
        GameState.redoStack.push(snapshot());
        const snap = GameState.undoStack.pop();
        restoreSnapshot(snap);
        playSfx("undo");
        toast(t("toast.undo"), true);
      }

      function redo() {
        if (GameState.redoStack.length === 0) {
          toast(t("toast.noRedo"), false);
          return;
        }
        GameState.undoStack.push(snapshot());
        const snap = GameState.redoStack.pop();
        restoreSnapshot(snap);
        playSfx("redo");
        toast(t("toast.redo"), true);
      }

      function createBoard() {
        els.board.innerHTML = "";
        GameState.cells = [];
        for (let i = 0; i < 81; i += 1) {
          const cell = document.createElement("button");
          cell.type = "button";
          cell.className = "cell";
          cell.dataset.row = String(Math.floor(i / 9));
          cell.dataset.col = String(i % 9);
          cell.addEventListener("click", () => {
            GameState.selected = i;
            UI.renderBoard();
          });
          els.board.appendChild(cell);
          GameState.cells.push(cell);
        }
      }

      function createNumPad() {
        els.numPad.innerHTML = "";
        for (const n of Constants.DIGITS) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "num-btn";
          btn.textContent = String(n);
          btn.addEventListener("click", () => writeNumber(n));
          els.numPad.appendChild(btn);
        }
      }

      function createDifficultyButtons() {
        els.difficultyRow.innerHTML = "";
        for (const key of Object.keys(DIFFICULTIES)) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.dataset.diff = key;
          btn.textContent = diffLabel(key);
          btn.addEventListener("click", () => {
            GameState.difficulty = key;
            UI.renderDifficultyButtons();
            UI.renderLeaderboard();
            startNewGame();
          });
          els.difficultyRow.appendChild(btn);
        }
      }

      function dailySeed(day, diff) {
        return hashString(`${day}:${diff}:daily`);
      }

      function startNewGame(options = {}) {
        const nowDay = localToday();
        if (GameState.mode === "daily") {
          GameState.day = options.day || nowDay;
          const seed = dailySeed(GameState.day, GameState.difficulty);
          Game.load(seed, options);
        } else {
          GameState.day = nowDay;
          const seed = (Date.now() ^ Math.floor(Math.random() * 0xffffffff)) >>> 0;
          Game.load(seed, options);
        }
      }

      function setMode(mode) {
        if (!["normal", "daily"].includes(mode)) return;
        GameState.mode = mode;
        GameState.day = localToday();
        startNewGame();
      }

      function setLanguage(lang) {
        Settings.language = lang;
        Storage.writeSettings();
        UI.applySettings();
        createDifficultyButtons();
        UI.renderDifficultyButtons();
        UI.updateBadges();
        UI.renderLeaderboard();
        UI.renderBoard();
      }

      function exportData() {
        try {
          const payload = {
            version: Constants.EXPORT_VERSION,
            exportedAt: new Date().toISOString(),
            scores: Storage.readScores(),
            dailyScores: Storage.readDailyScores(),
            settings: Settings,
          };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `sudoku-party-backup-${localToday().replaceAll("-", "")}.json`;
          a.click();
          URL.revokeObjectURL(url);
          toast(t("toast.export.ok"), true);
        } catch {
          toast(t("toast.export.fail"), false);
        }
      }

      async function importData(file) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          if (!data || data.version !== Constants.EXPORT_VERSION) {
            toast(t("toast.import.badVersion"), false);
            return;
          }

          if (data.scores && typeof data.scores === "object") Storage.writeScores(data.scores);
          if (data.dailyScores && typeof data.dailyScores === "object") Storage.writeDailyScores(data.dailyScores);
          if (data.settings && typeof data.settings === "object") {
            const s = data.settings;
            if (typeof s.mute === "boolean") Settings.mute = s.mute;
            if (Number.isFinite(s.volume)) Settings.volume = Math.max(0, Math.min(1, s.volume));
            if (["low", "medium", "high"].includes(s.effectIntensity)) Settings.effectIntensity = s.effectIntensity;
            if (typeof s.highContrast === "boolean") Settings.highContrast = s.highContrast;
            if (typeof s.largeFont === "boolean") Settings.largeFont = s.largeFont;
            if (["zh", "en"].includes(s.language)) Settings.language = s.language;
            Storage.writeSettings();
            UI.applySettings();
          }

          UI.renderLeaderboard();
          toast(t("toast.import.ok"), true);
        } catch {
          toast(t("toast.import.fail"), false);
        }
      }

      async function shareProgress() {
        URLSync.flush(true);
        const text = t("share.text", { url: window.location.href });
        try {
          if (navigator.share) {
            await navigator.share({ title: t("share.title"), text: t("share.invite"), url: window.location.href });
            toast(t("toast.share.system"), true);
            return;
          }
          if (navigator.clipboard) {
            await navigator.clipboard.writeText(text);
            toast(t("toast.share.copied"), true);
            return;
          }
          throw new Error("unsupported");
        } catch {
          toast(t("toast.share.fail"), false);
        }
      }

      async function copyDailyLink() {
        const u = new URL(window.location.href);
        u.searchParams.set("mode", "daily");
        u.searchParams.set("day", GameState.day);
        u.searchParams.set("diff", GameState.difficulty);
        u.searchParams.set("seed", String(dailySeed(GameState.day, GameState.difficulty)));
        u.searchParams.set("v", Constants.URL_VERSION);
        u.searchParams.delete("state");
        u.searchParams.delete("notes");
        u.searchParams.delete("t");
        u.searchParams.delete("p");

        try {
          if (navigator.clipboard) {
            await navigator.clipboard.writeText(u.toString());
            toast(t("toast.daily.copied"), true);
            return;
          }
          throw new Error("no clipboard");
        } catch {
          toast(t("toast.daily.copyFail"), false);
        }
      }

      function maybeConfirmNewGame() {
        const inProgress = !GameState.completed && !GameState.failed && GameState.state.some((v, i) => !GameState.fixed[i] && v !== 0);
        if (!inProgress) {
          startNewGame();
          return;
        }

        const coarse = window.matchMedia("(pointer: coarse)").matches;
        if (!coarse) {
          if (window.confirm(t("confirm.new.desktop"))) startNewGame();
          return;
        }

        if (!window.confirm(t("confirm.new.mobile"))) return;
        startNewGame();
      }

      function bindNewGameLongPress() {
        const btn = els.newGame;
        const coarse = window.matchMedia("(pointer: coarse)").matches;
        if (!coarse) {
          btn.addEventListener("click", maybeConfirmNewGame);
          return;
        }

        const start = () => {
          GameState.longPressTriggered = false;
          GameState.longPressTimer = setTimeout(() => {
            GameState.longPressTriggered = true;
            startNewGame();
            toast(t("toast.longPressNew"), true);
          }, 450);
        };

        const end = () => {
          if (GameState.longPressTimer) {
            clearTimeout(GameState.longPressTimer);
            GameState.longPressTimer = null;
          }
        };

        btn.addEventListener("pointerdown", start);
        btn.addEventListener("pointerup", () => {
          const wasLong = GameState.longPressTriggered;
          end();
          if (!wasLong) maybeConfirmNewGame();
        });
        btn.addEventListener("pointerleave", end);
        btn.addEventListener("pointercancel", end);
        btn.addEventListener("click", (e) => e.preventDefault());
      }

      function applyModeFromURL(url) {
        const m = url.searchParams.get("mode");
        if (m === "daily" || m === "normal") GameState.mode = m;
      }

      function bootstrapFromURL() {
        const url = new URL(window.location.href);
        applyModeFromURL(url);

        const diff = url.searchParams.get("diff");
        if (diff && DIFFICULTIES[diff]) GameState.difficulty = diff;

        const day = url.searchParams.get("day");
        GameState.day = day || localToday();

        const state = URLSync.decodeState(url.searchParams.get("state"));
        const notes = URLSync.decodeNotes(url.searchParams.get("notes"));
        const elapsed = Number(url.searchParams.get("t"));
        const penalty = Number(url.searchParams.get("p"));

        let seed = Number(url.searchParams.get("seed"));
        if (!Number.isFinite(seed) || seed <= 0) {
          seed = GameState.mode === "daily" ? dailySeed(GameState.day, GameState.difficulty) : ((Date.now() ^ Math.floor(Math.random() * 0xffffffff)) >>> 0);
        }

        if (GameState.mode === "daily") seed = dailySeed(GameState.day, GameState.difficulty);

        Game.load(seed, {
          progress: state,
          notes,
          elapsed: Number.isFinite(elapsed) ? elapsed : 0,
          penaltyPoints: Number.isFinite(penalty) ? penalty : 0,
          restore: Boolean(state || notes),
        });
      }

      function bindEvents() {
        document.addEventListener("pointerdown", ensureAudio, { passive: true });

        els.noteMode.addEventListener("click", () => {
          GameState.noteMode = !GameState.noteMode;
          playSfx("note");
          UI.renderBoard();
        });
        els.autoCandidates.addEventListener("click", autoCandidates);
        els.clearCandidates.addEventListener("click", clearCandidates);
        els.undo.addEventListener("click", undo);
        els.redo.addEventListener("click", redo);
        els.erase.addEventListener("click", erase);
        els.hint.addEventListener("click", giveHint);
        els.share.addEventListener("click", shareProgress);
        els.toggleSettings.addEventListener("click", () => {
          if (GameState.settingsModalOpen) UI.closeSettingsModal();
          else UI.openSettingsModal();
        });
        els.modeNormal.addEventListener("click", () => setMode("normal"));
        els.modeDaily.addEventListener("click", () => setMode("daily"));
        els.copyDailyLink.addEventListener("click", copyDailyLink);
        els.langZh.addEventListener("click", () => setLanguage("zh"));
        els.langEn.addEventListener("click", () => setLanguage("en"));

        bindNewGameLongPress();

        els.muteBtn.addEventListener("click", () => {
          Settings.mute = !Settings.mute;
          UI.applySettings();
          Storage.writeSettings();
          toast(Settings.mute ? t("toast.mute.on") : t("toast.mute.off"), true);
        });

        els.contrastBtn.addEventListener("click", () => {
          Settings.highContrast = !Settings.highContrast;
          UI.applySettings();
          Storage.writeSettings();
          toast(Settings.highContrast ? t("toast.contrast.on") : t("toast.contrast.off"), true);
        });

        els.fontBtn.addEventListener("click", () => {
          Settings.largeFont = !Settings.largeFont;
          UI.applySettings();
          Storage.writeSettings();
          toast(Settings.largeFont ? t("toast.font.on") : t("toast.font.off"), true);
        });

        els.volumeSlider.addEventListener("input", () => {
          Settings.volume = Number(els.volumeSlider.value);
          UI.applySettings();
          Storage.writeSettings();
          playTone(620, 0.03, "sine", 0.03);
        });

        for (const btn of els.effectRow.querySelectorAll("button")) {
          btn.addEventListener("click", () => {
            Settings.effectIntensity = btn.dataset.effect;
            UI.applySettings();
            Storage.writeSettings();
            toast(t("toast.effect", { name: t(`effect.${btn.dataset.effect}`) }), true);
          });
        }

        els.exportData.addEventListener("click", exportData);
        els.importData.addEventListener("click", () => els.importFile.click());
        els.importFile.addEventListener("change", async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          await importData(file);
          e.target.value = "";
        });

        els.resultClose.addEventListener("click", UI.closeResultModal);
        els.resultRetry.addEventListener("click", () => {
          UI.closeResultModal();
          startNewGame();
        });
        els.resultModal.addEventListener("click", (e) => {
          if (e.target === els.resultModal) UI.closeResultModal();
        });
        els.settingsClose.addEventListener("click", () => UI.closeSettingsModal());
        els.settingsModal.addEventListener("click", (e) => {
          if (e.target === els.settingsModal) UI.closeSettingsModal();
        });

        document.addEventListener("keydown", (e) => {
          if (els.resultModal.classList.contains("open")) {
            if (e.key === "Escape") {
              e.preventDefault();
              UI.closeResultModal();
              return;
            }
            if (e.key === "Tab") {
              UI.trapFocus(e, els.resultModal);
            }
            return;
          }
          if (GameState.settingsModalOpen) {
            if (e.key === "Escape") {
              e.preventDefault();
              UI.closeSettingsModal();
              return;
            }
            if (e.key === "Tab") {
              UI.trapFocus(e, els.settingsModal);
            }
            return;
          }

          ensureAudio();
          if (e.key >= "1" && e.key <= "9") {
            writeNumber(Number(e.key));
          } else if (e.key === "Backspace" || e.key === "Delete" || e.key === "0") {
            e.preventDefault();
            erase();
          } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
            if (e.shiftKey) redo();
            else undo();
          } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
            redo();
          } else if (e.key.toLowerCase() === "n") {
            e.preventDefault();
            GameState.noteMode = !GameState.noteMode;
            UI.renderBoard();
          } else if (e.key === "ArrowUp" && GameState.selected >= 9) {
            e.preventDefault();
            GameState.selected -= 9;
            UI.renderBoard();
          } else if (e.key === "ArrowDown" && GameState.selected <= 71 && GameState.selected >= 0) {
            e.preventDefault();
            GameState.selected += 9;
            UI.renderBoard();
          } else if (e.key === "ArrowLeft" && GameState.selected > 0) {
            e.preventDefault();
            GameState.selected -= 1;
            UI.renderBoard();
          } else if (e.key === "ArrowRight" && GameState.selected >= 0 && GameState.selected < 80) {
            e.preventDefault();
            GameState.selected += 1;
            UI.renderBoard();
          }
        });

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) return;
          if (!GameState.startedAt || GameState.completed || GameState.failed) return;
          GameState.elapsedSeconds = Math.floor((Date.now() - GameState.startedAt) / 1000);
          UI.updateTimer();
          URLSync.schedule();
        });

        window.addEventListener("beforeunload", () => URLSync.flush(true));
        window.addEventListener("resize", resizeFireworks);
      }

      function init() {
        Storage.readSettings();
        Storage.writeSettings();
        UI.applySettings();
        createBoard();
        createNumPad();
        createDifficultyButtons();
        resizeFireworks();
        bindEvents();
        bootstrapFromURL();
      }

      init();
    </script>
  </body>
</html>
